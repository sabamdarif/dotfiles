#!/bin/bash

# Set to true when going directly to a submenu, so we can exit directly
BACK_TO_EXIT=false

# Configuration paths
ROFI_FONT_CONFIG="$HOME/.config/rofi/themes/fonts.rasi"
SWAYNC_FONT_CONFIG="$HOME/.config/swaync/fonts.css"
SWAYLOCK_FONT_CONFIG="$HOME/.config/swaylock/font"
ROFI_ICON_CONFIG="$HOME/.config/rofi/themes/icons.rasi"
WAYBAR_FONT_CONFIG="$HOME/.config/waybar/fonts.css"
GTK_CONFIG="$HOME/.config/gtk-3.0/settings.ini"
QT_CONFIG="$HOME/.config/qt5ct/qt5ct.conf"
NIRI_CONFIG="$HOME/.config/niri/config.kdl"
HYPRLAND_CONFIG="$HOME/.config/hypr/hyprland.conf"
SWAY_CONFIG="$HOME/.config/sway/config"
THEME_MENU_SCRIPT="$HOME/.config/rofi/bin/theme-changer-menu"
IDLE_TIME_FILE="$HOME/.local/state/idle-time"
IDLE_SCRIPT="$HOME/.config/niri/scripts/idle.sh"
DEFAULT_APPS_MENU_SCRIPT="$HOME/.config/rofi/bin/set-default-app-menu"

back_to() {
    local parent_menu="$1"

    if [[ "$BACK_TO_EXIT" == "true" ]]; then
        exit 0
    elif [[ -n "$parent_menu" ]]; then
        "$parent_menu"
    else
        show_main_menu
    fi
}

menu() {
    local prompt="$1"
    local options="$2"
    local extra="$3"
    local preselect="$4"

    read -r -a args <<<"$extra"

    if [[ -n "$preselect" ]]; then
        local index
        index=$(echo -e "$options" | grep -nxF "$preselect" | cut -d: -f1)
        if [[ -n "$index" ]]; then
            args+=("-c" "$index")
        fi
    fi

    echo -e "$options" | rofi -dmenu -p "$prompt" -theme ~/.config/rofi/settings-menu.rasi "${args[@]}" 2>/dev/null
}

notify() {
    notify-send "$1" "$2"
}

# ============================================================================
# Font Management Functions
# ============================================================================

list_fonts() {
    # List all available fonts from the system
    fc-list : family | sort -u
}

get_current_font() {
    # Try to get current font from rofi config
    if [[ -f "$ROFI_FONT_CONFIG" ]]; then
        grep -oP 'font:\s*"\K[^"]+' "$ROFI_FONT_CONFIG" | head -1
    else
        echo "FantasqueSansM Nerd Font Propo 13"
    fi
}

set_rofi_font() {
    local font_name="$1"
    local font_size="${2:-13}"
    local small_size="${3:-11}"

    # Create rofi config directory if it doesn't exist
    mkdir -p "$(dirname "$ROFI_FONT_CONFIG")"

    # Create or update rofi font configuration
    cat >"$ROFI_FONT_CONFIG" <<EOF
* {
  font: "$font_name, FantasqueSansM Nerd Font Propo $font_size";
}

element-text {
  font: "$font_name, FantasqueSansM Nerd Font Propo $small_size";
}
EOF
}

set_swaync_font() {
    local font_name="$1"

    # Create waybar config directory if it doesn't exist
    mkdir -p "$(dirname "$SWAYNC_FONT_CONFIG")"

    # Create or update waybar font configuration
    cat >"$SWAYNC_FONT_CONFIG" <<EOF
* {
  font-family: "$font_name, FantasqueSansM Nerd Font Propo";
}
EOF
}

set_swaylock_font() {
    local font_name="$1"

    # Create waybar config directory if it doesn't exist
    mkdir -p "$(dirname "$SWAYLOCK_FONT_CONFIG")"

    # Create or update waybar font configuration
    cat >"$SWAYLOCK_FONT_CONFIG" <<EOF
    CUTTRNT_FONT="$font_name"
EOF
}

set_waybar_font() {
    local font_name="$1"

    # Create waybar config directory if it doesn't exist
    mkdir -p "$(dirname "$WAYBAR_FONT_CONFIG")"

    # Create or update waybar font configuration
    cat >"$WAYBAR_FONT_CONFIG" <<EOF
* {
  font-family: "$font_name, FantasqueSansM Nerd Font Propo";
}
EOF
}

set_gtk_font() {
    local font_name="$1"
    local font_size="${2:-11}"

    # Create GTK config directory if it doesn't exist
    mkdir -p "$(dirname "$GTK_CONFIG")"

    # Update or create GTK settings
    if [[ -f "$GTK_CONFIG" ]]; then
        # Update existing config
        sed -i "s/^gtk-font-name=.*/gtk-font-name=$font_name $font_size/" "$GTK_CONFIG"
    else
        # Create new config
        cat >"$GTK_CONFIG" <<EOF
[Settings]
gtk-font-name=$font_name $font_size
EOF
    fi
}

set_qt_font() {
    local font_name="$1"
    local font_size="${2:-11}"

    # Create Qt5 config directory if it doesn't exist
    mkdir -p "$(dirname "$QT_CONFIG")"

    # Update or create Qt5 settings
    if [[ -f "$QT_CONFIG" ]]; then
        # Update existing config
        sed -i "s/^fixed=.*/fixed=\"$font_name,$font_size,-1,5,50,0,0,0,0,0\"/" "$QT_CONFIG"
        sed -i "s/^general=.*/general=\"$font_name,$font_size,-1,5,50,0,0,0,0,0\"/" "$QT_CONFIG"
    else
        # Create new config
        cat >"$QT_CONFIG" <<EOF
[Fonts]
fixed="$font_name,$font_size,-1,5,50,0,0,0,0,0"
general="$font_name,$font_size,-1,5,50,0,0,0,0,0"
EOF
    fi
}

apply_font() {
    local font_selection="$1"

    # Extract just the font family name (remove any size info)
    local font_name=$(echo "$font_selection" | sed 's/[0-9]*$//' | xargs)

    if [[ -z "$font_name" ]]; then
        notify "Error" "No font selected"
        return 1
    fi

    notify "Applying Font" "Setting $font_name system-wide..."

    # Apply font to all configurations
    set_rofi_font "$font_name" "13" "11"
    set_waybar_font "$font_name"
    set_swaync_font "$font_name"
    set_swaylock_font "$font_name"
    set_gtk_font "$font_name" "11"
    set_qt_font "$font_name" "11"

    # Reload configurations if possible
    pkill -SIGUSR1 waybar 2>/dev/null
    gsettings set org.gnome.desktop.interface font-name "$font_name 11" 2>/dev/null

    # Run reload script if it exists
    if [[ -x "$HOME/.local/bin/reload_all" ]]; then
        "$HOME/.local/bin/reload_all" &
    fi

    notify "Font Applied" "$font_name has been set system-wide!"
}

show_font_menu() {
    local current_font=$(get_current_font)
    local font_list=$(list_fonts)

    local selected_font=$(menu "  Select Font" "$font_list" "" "$current_font")

    if [[ "$selected_font" == "CNCLD" || -z "$selected_font" ]]; then
        back_to show_main_menu
    else
        apply_font "$selected_font"
        back_to show_main_menu
    fi
}

# ============================================================================
# Theme Management Functions
# ============================================================================

show_theme_menu() {
    if [[ -x "$THEME_MENU_SCRIPT" ]]; then
        "$THEME_MENU_SCRIPT"
    else
        notify "Error" "Theme menu script not found at $THEME_MENU_SCRIPT"
    fi

    back_to show_main_menu
}

# ============================================================================
# Default Apps Management
# ============================================================================

show_default_apps_menu() {
    if [[ -x "$DEFAULT_APPS_MENU_SCRIPT" ]]; then
        "$DEFAULT_APPS_MENU_SCRIPT"
    else
        notify "Error" "Default apps menu script not found at $DEFAULT_APPS_MENU_SCRIPT"
    fi

    back_to show_main_menu
}

# ============================================================================
# Icon Management Functions
# ============================================================================

list_icon_themes() {
    # List all available icon themes from system and user directories
    find /usr/share/icons ~/.local/share/icons ~/.icons -maxdepth 1 -type d 2>/dev/null |
        xargs -I{} basename {} |
        grep -v "^icons$" |
        sort -u |
        grep -v "^hicolor$" |
        grep -v "^default$"
}

get_current_icon_theme() {
    # Try to get current icon theme from gsettings
    gsettings get org.gnome.desktop.interface icon-theme 2>/dev/null | tr -d "'"
}

set_icon_theme() {
    local icon_theme="$1"

    # Update Rofi icon theme config
    mkdir -p "$(dirname "$ROFI_ICON_CONFIG")"
    cat >"$ROFI_ICON_CONFIG" <<EOF
* {
  icon-theme: "$icon_theme";
}
EOF

    # Update gsettings
    gsettings set org.gnome.desktop.interface icon-theme "$icon_theme"

    # Update GTK 3.0 settings
    if [[ -f "$GTK_CONFIG" ]]; then
        sed -i "s/^gtk-icon-theme-name=.*/gtk-icon-theme-name=$icon_theme/" "$GTK_CONFIG"
    else
        mkdir -p "$(dirname "$GTK_CONFIG")"
        echo "[Settings]" >>"$GTK_CONFIG"
        echo "gtk-icon-theme-name=$icon_theme" >>"$GTK_CONFIG"
    fi

    # Update GTK 2.0 settings
    local GTK2_CONFIG="$HOME/.gtkrc-2.0"
    if grep -q "^gtk-icon-theme-name=" "$GTK2_CONFIG" 2>/dev/null; then
        sed -i "s/^gtk-icon-theme-name=.*/gtk-icon-theme-name=\"$icon_theme\"/" "$GTK2_CONFIG"
    else
        echo "gtk-icon-theme-name=\"$icon_theme\"" >>"$GTK2_CONFIG"
    fi

    # Update GTK 4.0 settings
    local GTK4_CONFIG="$HOME/.config/gtk-4.0/settings.ini"
    mkdir -p "$(dirname "$GTK4_CONFIG")"
    if [[ -f "$GTK4_CONFIG" ]]; then
        sed -i "s/^gtk-icon-theme-name=.*/gtk-icon-theme-name=$icon_theme/" "$GTK4_CONFIG"
    else
        echo "[Settings]" >>"$GTK4_CONFIG"
        echo "gtk-icon-theme-name=$icon_theme" >>"$GTK4_CONFIG"
    fi

    # Update xsettingsd for X11 apps
    local XSETTINGSD_CONFIG="$HOME/.config/xsettingsd/xsettingsd.conf"
    mkdir -p "$(dirname "$XSETTINGSD_CONFIG")"
    if grep -q "^Net/IconThemeName" "$XSETTINGSD_CONFIG" 2>/dev/null; then
        sed -i "s|^Net/IconThemeName.*|Net/IconThemeName \"$icon_theme\"|" "$XSETTINGSD_CONFIG"
    else
        echo "Net/IconThemeName \"$icon_theme\"" >>"$XSETTINGSD_CONFIG"
    fi

    # Restart xsettingsd if running
    pkill -HUP xsettingsd 2>/dev/null || killall -HUP xsettingsd 2>/dev/null
}

apply_icon_theme() {
    local icon_theme="$1"

    if [[ -z "$icon_theme" ]]; then
        notify "Error" "No icon theme selected"
        return 1
    fi

    notify "Applying Icon Theme" "Setting $icon_theme..."

    set_icon_theme "$icon_theme"

    # Run reload script if it exists
    if [[ -x "$HOME/.local/bin/reload_all" ]]; then
        "$HOME/.local/bin/reload_all" &
    fi

    notify "Icon Theme Applied" "$icon_theme has been set!"
}

show_icon_menu() {
    local current_theme=$(get_current_icon_theme)
    local theme_list=$(list_icon_themes)

    local selected_theme=$(menu "󰠱  Select Icon Theme" "$theme_list" "" "$current_theme")

    if [[ "$selected_theme" != "CNCLD" && -n "$selected_theme" ]]; then
        apply_icon_theme "$selected_theme"
    fi

    back_to show_main_menu
}

# ============================================================================
# Swayidle Timeout Management
# ============================================================================

get_current_idle_timeout() {
    if [[ -f "$IDLE_TIME_FILE" ]]; then
        cat "$IDLE_TIME_FILE"
    else
        echo "10 minutes"
    fi
}

set_idle_timeout() {
    local timeout="$1"

    if [[ -z "$timeout" ]]; then
        notify "Error" "No timeout selected"
        return 1
    fi

    # Create state directory if it doesn't exist
    mkdir -p "$(dirname "$IDLE_TIME_FILE")"

    # Write timeout to file
    echo "$timeout" >"$IDLE_TIME_FILE"

    notify "Idle Timeout Set" "Timeout set to $timeout"

    # Run idle script
    if [[ -x "$IDLE_SCRIPT" ]]; then
        bash "$IDLE_SCRIPT" &
        disown
    else
        notify "Warning" "Idle script not found at $IDLE_SCRIPT"
    fi
}

show_idle_menu() {
    local current_timeout=$(get_current_idle_timeout)
    local options="5 minutes\n10 minutes\n20 minutes\n30 minutes"

    local selected_timeout=$(menu "󰥔  Idle Timeout" "$options" "" "$current_timeout")

    if [[ "$selected_timeout" != "CNCLD" && -n "$selected_timeout" ]]; then
        set_idle_timeout "$selected_timeout"
    fi

    back_to show_main_menu
}

# ============================================================================
# Capture Management Functions
# ============================================================================

detect_compositor() {
    # Detect which compositor is running
    if [[ -n "$HYPRLAND_INSTANCE_SIGNATURE" ]]; then
        echo "hyprland"
    elif pgrep -x niri &>/dev/null; then
        echo "niri"
    elif pgrep -x sway &>/dev/null; then
        echo "sway"
    else
        echo "unknown"
    fi
}

capture_current_window() {
    bash "$HOME"/.config/niri/scripts/screenshot.sh --current-window
}

capture_select_area() {
    bash "$HOME"/.config/niri/scripts/screenshot.sh --select-area
}

capture_fullscreen() {
    bash "$HOME"/.config/niri/scripts/screenshot.sh --fullscreen
}

run_color_picker() {
    if [[ -x "$HOME/.local/bin/color-picker" ]]; then
        "$HOME/.local/bin/color-picker"
    else
        notify "Error" "Color picker script not found or not executable"
    fi
}

show_capture_menu() {
    local selection=$(menu "  Capture" "  Current Window\n󱗽  Select Area\n󰍹  Fullscreen\n  Color Picker")

    case "$selection" in
    *"Current Window"*) capture_current_window ;;
    *"Select Area"*) capture_select_area ;;
    *Fullscreen*) capture_fullscreen ;;
    *"Color Picker"*) run_color_picker ;;
    *) back_to show_main_menu ;;
    esac

    back_to show_main_menu
}

# ============================================================================
# System Reload Functions
# ============================================================================

show_update_menu() {
    if [[ -x "$HOME/.local/bin/reload_all" ]]; then
        "$HOME/.local/bin/reload_all" &
    fi
    back_to show_main_menu
}

# ============================================================================
# Keybinding Menu
# ============================================================================

parse_niri_keybinds() {
    local config_file="$1"
    local keybinds=""

    if [[ ! -f "$config_file" ]]; then
        echo "ERROR: Niri config not found at $config_file"
        return 1
    fi

    # Read the binds section
    local in_binds=false
    while IFS= read -r line; do
        # Detect binds section
        [[ "$line" =~ ^[[:space:]]*binds[[:space:]]*\{ ]] && in_binds=true
        [[ "$in_binds" == false ]] && continue

        # Exit binds section
        [[ "$line" =~ ^\}$ ]] && break

        # Parse bindings with overlay title
        if [[ "$line" =~ (Mod\+[^[:space:]]+|XF86[^[:space:]]+|Caps_Lock)[[:space:]]+hotkey-overlay-title=\"([^\"]+)\" ]]; then
            local key="${BASH_REMATCH[1]}"
            local desc="${BASH_REMATCH[2]}"
            keybinds+="$key|$desc\n"
        # Parse bindings without overlay title
        elif [[ "$line" =~ ^[[:space:]]*(Mod\+[^[:space:]]+|XF86[^[:space:]]+|Caps_Lock)[[:space:]]*\{[[:space:]]*([^;]+) ]]; then
            local key="${BASH_REMATCH[1]}"
            local action="${BASH_REMATCH[2]}"
            # Clean up action name
            action=$(echo "$action" | sed -E 's/spawn|exec//g' | sed 's/"//g' | xargs | cut -d' ' -f1)
            keybinds+="$key|$action\n"
        fi
    done <"$config_file"

    echo -e "$keybinds"
}

parse_hyprland_keybinds() {
    local config_file="$1"
    local keybinds=""

    if [[ ! -f "$config_file" ]]; then
        echo "ERROR: Hyprland config not found at $config_file"
        return 1
    fi

    # Get $mod value
    local mod_key=$(grep -m1 '^\$mod[[:space:]]*=' "$config_file" | cut -d'=' -f2 | xargs)
    [[ -z "$mod_key" ]] && mod_key="SUPER"

    while IFS= read -r line; do
        # Skip empty lines
        [[ -z "$line" || "$line" =~ ^[[:space:]]*$ ]] && continue

        # Parse bind lines: bind[e|l|m|de] = modifiers, key, action, [params]
        if [[ "$line" =~ ^bind[elmd]*[[:space:]]*=[[:space:]]*([^,]+),[[:space:]]*([^,]+),[[:space:]]*([^,]+)(,(.+))?$ ]]; then
            local mods="${BASH_REMATCH[1]}"
            local key="${BASH_REMATCH[2]}"
            local action="${BASH_REMATCH[3]}"
            local params="${BASH_REMATCH[5]}"

            # Replace variables
            mods="${mods//\$mod/$mod_key}"
            mods=$(echo "$mods" | xargs)
            key=$(echo "$key" | xargs)
            action=$(echo "$action" | xargs)
            params=$(echo "$params" | xargs)

            # Build keybind string
            local keybind="$mods+$key"
            keybind="${keybind// /+}"

            # Build description
            local desc="$action"
            [[ -n "$params" ]] && desc="$action: $params"

            keybinds+="$keybind|$desc\n"
        fi
    done < <(grep -v "^#" "$config_file" | grep "^bind")

    echo -e "$keybinds"
}

parse_sway_keybinds() {
    local config_file="$1"
    local keybinds=""

    if [[ ! -f "$config_file" ]]; then
        echo "ERROR: Sway config not found at $config_file"
        return 1
    fi

    # Get variables
    local mod_key=$(grep -m1 'set \$mod ' "$config_file" | awk '{print $3}')
    [[ -z "$mod_key" ]] && mod_key="Mod4"

    # Get directional variables if they exist
    local left=$(grep 'set \$left' "$config_file" | awk '{print $3}')
    local down=$(grep 'set \$down' "$config_file" | awk '{print $3}')
    local up=$(grep 'set \$up' "$config_file" | awk '{print $3}')
    local right=$(grep 'set \$right' "$config_file" | awk '{print $3}')

    while IFS= read -r line; do
        # Skip comments and empty
        [[ "$line" =~ ^[[:space:]]*# ]] && continue
        [[ -z "$line" ]] && continue

        # Parse bindsym: bindsym [options] keybind action
        if [[ "$line" =~ ^bindsym[[:space:]]+(--[^[:space:]]+[[:space:]]+)?([^[:space:]]+)[[:space:]]+(.+)$ ]]; then
            local options="${BASH_REMATCH[1]}"
            local keybind="${BASH_REMATCH[2]}"
            local action="${BASH_REMATCH[3]}"

            # Replace variables
            keybind="${keybind//\$mod/$mod_key}"
            [[ -n "$left" ]] && keybind="${keybind//\$left/$left}"
            [[ -n "$down" ]] && keybind="${keybind//\$down/$down}"
            [[ -n "$up" ]] && keybind="${keybind//\$up/$up}"
            [[ -n "$right" ]] && keybind="${keybind//\$right/$right}"

            # Clean action
            action=$(echo "$action" | sed 's/exec //g' | xargs)

            keybinds+="$keybind|$action\n"
        fi
    done < <(grep "^bindsym" "$config_file")

    echo -e "$keybinds"
}

# ============================================================================
# Keybinding Menu
# ============================================================================

format_keybinds_for_rofi() {
    local keybinds="$1"
    local formatted=""

    while IFS='|' read -r key description; do
        [[ -z "$key" ]] && continue

        # Format with nice alignment (adjust width as needed)
        printf -v line "%-40s → %s" "$key" "$description"
        formatted+="$line\n"
    done <<<"$keybinds"

    echo -e "$formatted"
}

show_keybinds() {
    local compositor_name="$1"
    local keybinds="$2"
    local icon="$3"

    if [[ "$keybinds" == "ERROR:"* ]]; then
        notify "Error" "$keybinds"
        return 1
    fi

    local formatted=$(format_keybinds_for_rofi "$keybinds" | sort)
    local count=$(echo -e "$formatted" | wc -l)

    # Show in rofi with search functionality
    local selection=$(echo -e "$formatted" | rofi -dmenu \
        -i \
        -p "$icon  $compositor_name Keybindings" \
        -theme ~/.config/rofi/clipboard-monitor.rasi \
        -mesg "󰍉 Type to search | Total: $count keybinds" \
        -no-custom \
        -format "s" \
        2>/dev/null)

    local exit_code=$?

    # Handle clipboard operations
    if [[ -n "$selection" ]]; then
        if [[ $exit_code -eq 10 ]]; then
            # Alt+c: Copy just the keybind
            local keybind=$(echo "$selection" | awk -F'→' '{print $1}' | xargs)
            echo -n "$keybind" | wl-copy
            notify "Copied to Clipboard" "$keybind"
        elif [[ $exit_code -eq 11 ]]; then
            # Alt+Return: Copy full line
            echo -n "$selection" | wl-copy
            notify "Copied to Clipboard" "Full keybinding info"
        fi
    fi
}

show_niri_keybinds() {
    local keybinds=$(parse_niri_keybinds "$(dirname "$NIRI_CONFIG")"/config.d/keybinding.kdl)
    show_keybinds "Niri" "$keybinds" ""
}

show_hyprland_keybinds() {
    local keybinds=$(parse_hyprland_keybinds "$HYPRLAND_CONFIG")
    show_keybinds "Hyprland" "$keybinds" ""
}

show_sway_keybinds() {
    local keybinds=$(parse_sway_keybinds "$SWAY_CONFIG")
    show_keybinds "Sway" "$keybinds" ""
}

# ============================================================================
# Keybinding Menu
# ============================================================================

show_keybind_menu() {
    local compositor=$(detect_compositor)

    case "$compositor" in
    niri)
        # Offer multiple options for niri
        local choice=$(menu "󰌌  Keybindings" "󰌌  All Keybindings\n  Applications Only\n󱂬  Window Management\n󱇚  Workspaces")

        case "$choice" in
        *"All Keybindings"*)
            show_niri_keybinds
            ;;
        *"Applications"*)
            local keybinds=$(parse_niri_keybinds "$NIRI_CONFIG" | grep -iE "spawn|open|launch|terminal|browser|file")
            show_keybinds "Niri (Applications)" "$keybinds" ""
            ;;
        *"Window"*)
            local keybinds=$(parse_niri_keybinds "$NIRI_CONFIG" | grep -iE "window|focus|move|close|fullscreen|maximize")
            show_keybinds "Niri (Windows)" "$keybinds" "󱂬"
            ;;
        *"Workspaces"*)
            local keybinds=$(parse_niri_keybinds "$NIRI_CONFIG" | grep -iE "workspace")
            show_keybinds "Niri (Workspaces)" "$keybinds" "󱇚"
            ;;
        esac
        ;;
    hyprland)
        show_hyprland_keybinds
        ;;
    sway)
        show_sway_keybinds
        ;;
    *)
        notify "Not Supported" "Keybinding viewer not available for: $compositor"
        ;;
    esac
}

show_keybindings_menu() {
    show_keybind_menu
    back_to show_main_menu
}

# ============================================================================
# About Menu
# ============================================================================

get_default_terminal() {
    # Get terminal from environment variable or use ghostty as default
    echo "${TERMINAL:-ghostty}"
}

run_info_check() {
    local terminal=$(get_default_terminal)

    if [[ "$terminal" == "ghostty" ]]; then
        "$terminal" --fullscreen=false --title="Fastfetch" -e bash -c "fastfetch; read -p 'Press Enter to close...'"
    else
        "$terminal" -e bash -c "fastfetch; echo ''; read -p 'Press Enter to close...'"
    fi
}

show_about_menu() {
    run_info_check
    back_to show_main_menu
}

# ============================================================================
# Main Menu
# ============================================================================

show_main_menu() {
    local selection=$(menu "  Settings" "  Font\n󰸌  Theme\n󰏋  Default Apps\n󰠱  Icons\n󰥔  Idle Timeout\n  Capture\n  Reload\n󰌌  Keybindings\n  About")

    case "$selection" in
    *Font*) show_font_menu ;;
    *Theme*) show_theme_menu ;;
    *Icons*) show_icon_menu ;;
    *"Default Apps"*) show_default_apps_menu ;;
    *"Idle Timeout"*) show_idle_menu ;;
    *Capture*) show_capture_menu ;;
    *Reload*) show_update_menu ;;
    *Keybindings*) show_keybindings_menu ;;
    *About*) show_about_menu ;;
    *) exit 0 ;;
    esac
}

# ============================================================================
# Entry Point
# ============================================================================

go_to_menu() {
    case "${1,,}" in
    *font*) show_font_menu ;;
    *theme*) show_theme_menu ;;
    *icon*) show_icon_menu ;;
    *"default"* | *"apps"*) show_default_apps_menu ;;
    *"Idle Timeout"*) show_idle_menu ;;
    *capture*) show_capture_menu ;;
    *refresh*) show_update_menu ;;
    *keybind*) show_keybindings_menu ;;
    *about*) show_about_menu ;;
    *) show_main_menu ;;
    esac
}

if [[ -n "$1" ]]; then
    BACK_TO_EXIT=true
    go_to_menu "$1"
else
    show_main_menu
fi
