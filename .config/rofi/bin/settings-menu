#!/bin/bash

# Set to true when going directly to a submenu, so we can exit directly
BACK_TO_EXIT=false

# Configuration paths
ROFI_FONT_CONFIG="$HOME/.config/rofi/themes/fonts.rasi"
SWAYNC_FONT_CONFIG="$HOME/.config/swaync/fonts.css"
ROFI_ICON_CONFIG="$HOME/.config/rofi/themes/icons.rasi"
WAYBAR_FONT_CONFIG="$HOME/.config/waybar/fonts.css"
GTK_CONFIG="$HOME/.config/gtk-3.0/settings.ini"
QT_CONFIG="$HOME/.config/qt5ct/qt5ct.conf"

back_to() {
    local parent_menu="$1"

    if [[ "$BACK_TO_EXIT" == "true" ]]; then
        exit 0
    elif [[ -n "$parent_menu" ]]; then
        "$parent_menu"
    else
        show_main_menu
    fi
}

menu() {
    local prompt="$1"
    local options="$2"
    local extra="$3"
    local preselect="$4"

    read -r -a args <<<"$extra"

    if [[ -n "$preselect" ]]; then
        local index
        index=$(echo -e "$options" | grep -nxF "$preselect" | cut -d: -f1)
        if [[ -n "$index" ]]; then
            args+=("-c" "$index")
        fi
    fi

    echo -e "$options" | rofi -dmenu -p "$prompt" -theme ~/.config/rofi/settings-menu.rasi "${args[@]}" 2>/dev/null
}

notify() {
    notify-send "$1" "$2"
}

# ============================================================================
# Font Management Functions
# ============================================================================

list_fonts() {
    # List all available fonts from the system
    fc-list : family | sort -u
}

get_current_font() {
    # Try to get current font from rofi config
    if [[ -f "$ROFI_FONT_CONFIG" ]]; then
        grep -oP 'font:\s*"\K[^"]+' "$ROFI_FONT_CONFIG" | head -1
    else
        echo "FantasqueSansM Nerd Font Propo 13"
    fi
}

set_rofi_font() {
    local font_name="$1"
    local font_size="${2:-13}"
    local small_size="${3:-11}"

    # Create rofi config directory if it doesn't exist
    mkdir -p "$(dirname "$ROFI_FONT_CONFIG")"

    # Create or update rofi font configuration
    cat >"$ROFI_FONT_CONFIG" <<EOF
* {
  font: "$font_name, FantasqueSansM Nerd Font Propo $font_size";
}

element-text {
  font: "$font_name, FantasqueSansM Nerd Font Propo $small_size";
}
EOF
}

set_swaync_font() {
    local font_name="$1"

    # Create waybar config directory if it doesn't exist
    mkdir -p "$(dirname "$SWAYNC_FONT_CONFIG")"

    # Create or update waybar font configuration
    cat >"$SWAYNC_FONT_CONFIG" <<EOF
* {
  font-family: "$font_name, FantasqueSansM Nerd Font Propo";
}
EOF
}

set_waybar_font() {
    local font_name="$1"

    # Create waybar config directory if it doesn't exist
    mkdir -p "$(dirname "$WAYBAR_FONT_CONFIG")"

    # Create or update waybar font configuration
    cat >"$WAYBAR_FONT_CONFIG" <<EOF
* {
  font-family: "$font_name, FantasqueSansM Nerd Font Propo";
}
EOF
}

set_gtk_font() {
    local font_name="$1"
    local font_size="${2:-11}"

    # Create GTK config directory if it doesn't exist
    mkdir -p "$(dirname "$GTK_CONFIG")"

    # Update or create GTK settings
    if [[ -f "$GTK_CONFIG" ]]; then
        # Update existing config
        sed -i "s/^gtk-font-name=.*/gtk-font-name=$font_name $font_size/" "$GTK_CONFIG"
    else
        # Create new config
        cat >"$GTK_CONFIG" <<EOF
[Settings]
gtk-font-name=$font_name $font_size
EOF
    fi
}

set_qt_font() {
    local font_name="$1"
    local font_size="${2:-11}"

    # Create Qt5 config directory if it doesn't exist
    mkdir -p "$(dirname "$QT_CONFIG")"

    # Update or create Qt5 settings
    if [[ -f "$QT_CONFIG" ]]; then
        # Update existing config
        sed -i "s/^fixed=.*/fixed=\"$font_name,$font_size,-1,5,50,0,0,0,0,0\"/" "$QT_CONFIG"
        sed -i "s/^general=.*/general=\"$font_name,$font_size,-1,5,50,0,0,0,0,0\"/" "$QT_CONFIG"
    else
        # Create new config
        cat >"$QT_CONFIG" <<EOF
[Fonts]
fixed="$font_name,$font_size,-1,5,50,0,0,0,0,0"
general="$font_name,$font_size,-1,5,50,0,0,0,0,0"
EOF
    fi
}

apply_font() {
    local font_selection="$1"

    # Extract just the font family name (remove any size info)
    local font_name=$(echo "$font_selection" | sed 's/[0-9]*$//' | xargs)

    if [[ -z "$font_name" ]]; then
        notify "Error" "No font selected"
        return 1
    fi

    notify "Applying Font" "Setting $font_name system-wide..."

    # Apply font to all configurations
    set_rofi_font "$font_name" "13" "11"
    set_waybar_font "$font_name"
    set_swaync_font "$font_name"
    set_gtk_font "$font_name" "11"
    set_qt_font "$font_name" "11"

    # Reload configurations if possible
    pkill -SIGUSR1 waybar 2>/dev/null
    gsettings set org.gnome.desktop.interface font-name "$font_name 11" 2>/dev/null

    # Run reload script if it exists
    if [[ -x "$HOME/.local/bin/reload_all" ]]; then
        "$HOME/.local/bin/reload_all" &
    fi

    notify "Font Applied" "$font_name has been set system-wide!"
}

show_font_menu() {
    local current_font=$(get_current_font)
    local font_list=$(list_fonts)

    local selected_font=$(menu "Select Font" "$font_list" "" "$current_font")

    if [[ "$selected_font" == "CNCLD" || -z "$selected_font" ]]; then
        back_to show_main_menu
    else
        apply_font "$selected_font"
        back_to show_main_menu
    fi
}

# ============================================================================
# Theme Management Functions (Placeholder)
# ============================================================================

show_theme_menu() {
    # Placeholder for theme selection
    local themes="  Dark Theme\n  Light Theme\n  Catppuccin\n  Nord\n  Dracula"

    local selected=$(menu "Select Theme" "$themes")

    if [[ "$selected" != "CNCLD" && -n "$selected" ]]; then
        notify "Theme" "Theme switching coming soon!"
    fi

    back_to show_main_menu
}

# ============================================================================
# Icon Management Functions
# ============================================================================

list_icon_themes() {
    # List all available icon themes from system and user directories
    find /usr/share/icons ~/.local/share/icons ~/.icons -maxdepth 1 -type d 2>/dev/null |
        xargs -I{} basename {} |
        grep -v "^icons$" |
        sort -u |
        grep -v "^hicolor$" |
        grep -v "^default$"
}

get_current_icon_theme() {
    # Try to get current icon theme from gsettings
    gsettings get org.gnome.desktop.interface icon-theme 2>/dev/null | tr -d "'"
}

set_icon_theme() {
    local icon_theme="$1"

    # Update Rofi icon theme config
    mkdir -p "$(dirname "$ROFI_ICON_CONFIG")"
    cat >"$ROFI_ICON_CONFIG" <<EOF
* {
  icon-theme: "$icon_theme";
}
EOF

    # Update gsettings
    gsettings set org.gnome.desktop.interface icon-theme "$icon_theme"

    # Update GTK 3.0 settings
    if [[ -f "$GTK_CONFIG" ]]; then
        sed -i "s/^gtk-icon-theme-name=.*/gtk-icon-theme-name=$icon_theme/" "$GTK_CONFIG"
    else
        mkdir -p "$(dirname "$GTK_CONFIG")"
        echo "[Settings]" >>"$GTK_CONFIG"
        echo "gtk-icon-theme-name=$icon_theme" >>"$GTK_CONFIG"
    fi

    # Update GTK 2.0 settings
    local GTK2_CONFIG="$HOME/.gtkrc-2.0"
    if grep -q "^gtk-icon-theme-name=" "$GTK2_CONFIG" 2>/dev/null; then
        sed -i "s/^gtk-icon-theme-name=.*/gtk-icon-theme-name=\"$icon_theme\"/" "$GTK2_CONFIG"
    else
        echo "gtk-icon-theme-name=\"$icon_theme\"" >>"$GTK2_CONFIG"
    fi

    # Update GTK 4.0 settings
    local GTK4_CONFIG="$HOME/.config/gtk-4.0/settings.ini"
    mkdir -p "$(dirname "$GTK4_CONFIG")"
    if [[ -f "$GTK4_CONFIG" ]]; then
        sed -i "s/^gtk-icon-theme-name=.*/gtk-icon-theme-name=$icon_theme/" "$GTK4_CONFIG"
    else
        echo "[Settings]" >>"$GTK4_CONFIG"
        echo "gtk-icon-theme-name=$icon_theme" >>"$GTK4_CONFIG"
    fi

    # Update xsettingsd for X11 apps
    local XSETTINGSD_CONFIG="$HOME/.config/xsettingsd/xsettingsd.conf"
    mkdir -p "$(dirname "$XSETTINGSD_CONFIG")"
    if grep -q "^Net/IconThemeName" "$XSETTINGSD_CONFIG" 2>/dev/null; then
        sed -i "s|^Net/IconThemeName.*|Net/IconThemeName \"$icon_theme\"|" "$XSETTINGSD_CONFIG"
    else
        echo "Net/IconThemeName \"$icon_theme\"" >>"$XSETTINGSD_CONFIG"
    fi

    # Restart xsettingsd if running
    pkill -HUP xsettingsd 2>/dev/null || killall -HUP xsettingsd 2>/dev/null
}

apply_icon_theme() {
    local icon_theme="$1"

    if [[ -z "$icon_theme" ]]; then
        notify "Error" "No icon theme selected"
        return 1
    fi

    notify "Applying Icon Theme" "Setting $icon_theme..."

    set_icon_theme "$icon_theme"

    # Run reload script if it exists
    if [[ -x "$HOME/.local/bin/reload_all" ]]; then
        "$HOME/.local/bin/reload_all" &
    fi

    notify "Icon Theme Applied" "$icon_theme has been set!"
}

show_icon_menu() {
    local current_theme=$(get_current_icon_theme)
    local theme_list=$(list_icon_themes)

    local selected_theme=$(menu "Select Icon Theme" "$theme_list" "" "$current_theme")

    if [[ "$selected_theme" != "CNCLD" && -n "$selected_theme" ]]; then
        apply_icon_theme "$selected_theme"
    fi

    back_to show_main_menu
}

# ============================================================================
# Capture Management Functions
# ============================================================================

detect_compositor() {
    # Detect which compositor is running
    if [[ -n "$HYPRLAND_INSTANCE_SIGNATURE" ]]; then
        echo "hyprland"
    elif pgrep -x niri &>/dev/null; then
        echo "niri"
    elif pgrep -x sway &>/dev/null; then
        echo "sway"
    else
        echo "unknown"
    fi
}

capture_current_window() {
    # Create screenshots directory if it doesn't exist
    mkdir -p ~/Pictures/Screenshots

    local compositor=$(detect_compositor)
    local filename=~/Pictures/Screenshots/window-$(date +%Y%m%d_%H%M%S).png

    case "$compositor" in
    hyprland)
        grimblast copysave active "$filename" 2>/dev/null
        if [[ -f "$filename" && -s "$filename" ]]; then
            notify-send -i "$filename" "ðŸ“¸ Screenshot saved" "Window captured"
        fi
        ;;

    niri)
        # Capture window to clipboard
        niri msg action screenshot-window

        # Save from clipboard to file
        wl-paste >"$filename"

        if [[ -f "$filename" && -s "$filename" ]]; then
            notify-send -i "$filename" "ðŸ“¸ Screenshot saved" "Window captured"
        fi
        ;;

    sway)
        # Get focused window from sway
        local window_info=$(swaymsg -t get_tree | jq -r '.. | select(.focused? == true)')

        if [[ -z "$window_info" ]]; then
            return 1
        fi

        # Parse window geometry
        local x=$(echo "$window_info" | jq -r '.rect.x // 0')
        local y=$(echo "$window_info" | jq -r '.rect.y // 0')
        local width=$(echo "$window_info" | jq -r '.rect.width // 0')
        local height=$(echo "$window_info" | jq -r '.rect.height // 0')

        # Check if we got valid geometry
        if [[ "$width" -eq 0 || "$height" -eq 0 ]]; then
            return 1
        fi

        # Capture the window
        grim -g "${x},${y} ${width}x${height}" "$filename" 2>/dev/null

        if [[ $? -eq 0 && -f "$filename" && -s "$filename" ]]; then
            wl-copy <"$filename"
            notify-send -i "$filename" "ðŸ“¸ Screenshot saved" "Window captured"
        fi
        ;;

    *)
        notify "Error" "Unsupported compositor"
        return 1
        ;;
    esac
}

capture_select_area() {
    # Create screenshots directory if it doesn't exist
    mkdir -p ~/Pictures/Screenshots

    local filename=~/Pictures/Screenshots/area-$(date +%Y%m%d_%H%M%S).png

    # Use slurp to select area, then grim to capture
    local geometry=$(slurp -b '#00000066' -c '#ffffffff' -w 2 2>/dev/null)

    # Only proceed if user selected an area (didn't cancel)
    if [[ -n "$geometry" ]]; then
        grim -g "$geometry" "$filename" 2>/dev/null

        # Only send notification if screenshot was actually saved
        if [[ -f "$filename" && -s "$filename" ]]; then
            wl-copy <"$filename"
            notify-send -i "$filename" "ðŸ“¸ Screenshot saved" "Area captured"
        fi
    fi
}

capture_fullscreen() {
    # Create screenshots directory if it doesn't exist
    mkdir -p ~/Pictures/Screenshots

    local compositor=$(detect_compositor)
    local filename=~/Pictures/Screenshots/fullscreen-$(date +%Y%m%d_%H%M%S).png

    case "$compositor" in
    hyprland)
        grimblast copysave screen "$filename" 2>/dev/null
        if [[ -f "$filename" && -s "$filename" ]]; then
            notify-send -i "$filename" "ðŸ“¸ Screenshot saved" "Fullscreen captured"
        fi
        ;;

    niri | sway | *)
        # grim works universally on all Wayland compositors
        grim "$filename" 2>/dev/null

        if [[ -f "$filename" && -s "$filename" ]]; then
            wl-copy <"$filename"
            notify-send -i "$filename" "ðŸ“¸ Screenshot saved" "Fullscreen captured"
        fi
        ;;
    esac
}

run_color_picker() {
    if [[ -x "$HOME/.local/bin/color-picker" ]]; then
        "$HOME/.local/bin/color-picker"
    else
        notify "Error" "Color picker script not found or not executable"
    fi
}

show_capture_menu() {
    local selection=$(menu "Capture" "  Current Window\n  Select Area\n  Fullscreen\n  Color Picker")

    case "$selection" in
    *"Current Window"*) capture_current_window ;;
    *"Select Area"*) capture_select_area ;;
    *Fullscreen*) capture_fullscreen ;;
    *"Color Picker"*) run_color_picker ;;
    *) back_to show_main_menu ;;
    esac

    back_to show_main_menu
}

# ============================================================================
# System Reload Functions
# ============================================================================

show_update_menu() {
    if [[ -x "$HOME/.local/bin/reload_all" ]]; then
        "$HOME/.local/bin/reload_all" &
    fi
    back_to show_main_menu
}

# ============================================================================
# Keybinding Menu (Placeholder)
# ============================================================================

show_keybindings_menu() {
    notify "Keybindings" "Keybinding configuration coming soon!"
    back_to show_main_menu
}

# ============================================================================
# About Menu (Placeholder)
# ============================================================================
get_default_terminal() {
    # Get terminal from environment variable or use ghostty as default
    echo "${TERMINAL:-ghostty}"
}

run_info_check() {
    local terminal=$(get_default_terminal)

    # Run fastfetch and wait for user to press enter
    "$terminal" -e bash -c "fastfetch; echo ''; read -p 'Press Enter to close...'"
}

show_about_menu() {
    run_info_check
    back_to show_main_menu
}

# ============================================================================
# Main Menu
# ============================================================================

show_main_menu() {
    local selection=$(menu "Settings" "  Font\nó°¸Œ  Theme\n  Icons\n  Capture\n  Refresh\n  Keybindings\n  About")

    case "$selection" in
    *Font*) show_font_menu ;;
    *Theme*) show_theme_menu ;;
    *Icons*) show_icon_menu ;;
    *Capture*) show_capture_menu ;;
    *Refresh*) show_update_menu ;;
    *Keybindings*) show_keybindings_menu ;;
    *About*) show_about_menu ;;
    *) exit 0 ;;
    esac
}

# ============================================================================
# Entry Point
# ============================================================================

go_to_menu() {
    case "${1,,}" in
    *font*) show_font_menu ;;
    *theme*) show_theme_menu ;;
    *icon*) show_icon_menu ;;
    *capture*) show_capture_menu ;;
    *refresh*) show_update_menu ;;
    *keybind*) show_keybindings_menu ;;
    *about*) show_about_menu ;;
    *) show_main_menu ;;
    esac
}

if [[ -n "$1" ]]; then
    BACK_TO_EXIT=true
    go_to_menu "$1"
else
    show_main_menu
fi
