#!/bin/bash

# Real-time Package Installation Monitor Script
# Monitors package manager activity and tracks installations in real-time

# Configuration
MONITOR_FILE="/tmp/pkg_monitor_$$"
INSTALLED_PACKAGES="/tmp/installed_packages_$$"
LOCK_FILE="/tmp/pkg_monitor.lock"
LOG_FILE="/tmp/pkg_monitor_$$.log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to detect package manager
detect_package_manager() {
    if command -v apt >/dev/null 2>&1; then
        echo "apt"
    elif command -v dnf >/dev/null 2>&1; then
        echo "dnf"
    elif command -v yum >/dev/null 2>&1; then
        echo "yum"
    elif command -v pacman >/dev/null 2>&1; then
        echo "pacman"
    elif command -v zypper >/dev/null 2>&1; then
        echo "zypper"
    else
        echo "unknown"
    fi
}

# Function to get current installed packages list
get_package_list() {
    local pm="$1"
    case "$pm" in
    "apt")
        dpkg --get-selections | grep -v deinstall | awk '{print $1}' | sort
        ;;
    "dnf" | "yum")
        rpm -qa --queryformat '%{NAME}\n' | sort
        ;;
    "pacman")
        pacman -Q | awk '{print $1}' | sort
        ;;
    "zypper")
        rpm -qa --queryformat '%{NAME}\n' | sort
        ;;
    *)
        echo "Unsupported package manager: $pm" >&2
        exit 1
        ;;
    esac
}

# Function to get uninstall command
get_uninstall_command() {
    local pm="$1"
    case "$pm" in
    "apt")
        echo "sudo apt remove"
        ;;
    "dnf")
        echo "sudo dnf remove"
        ;;
    "yum")
        echo "sudo yum remove"
        ;;
    "pacman")
        echo "sudo pacman -R"
        ;;
    "zypper")
        echo "sudo zypper remove"
        ;;
    *)
        echo "# Unknown package manager"
        ;;
    esac
}

# Function to monitor package manager processes
monitor_package_processes() {
    local pm="$1"
    local verbose="$2"

    case "$pm" in
    "apt")
        PROCESS_NAMES="apt apt-get aptitude dpkg"
        ;;
    "dnf")
        PROCESS_NAMES="dnf"
        ;;
    "yum")
        PROCESS_NAMES="yum"
        ;;
    "pacman")
        PROCESS_NAMES="pacman"
        ;;
    "zypper")
        PROCESS_NAMES="zypper"
        ;;
    *)
        PROCESS_NAMES=""
        ;;
    esac

    while true; do
        # Check if any package manager is running
        PKG_RUNNING=false
        for proc in $PROCESS_NAMES; do
            if pgrep -f "$proc" >/dev/null 2>&1; then
                PKG_RUNNING=true
                if [[ "$verbose" == "true" ]]; then
                    echo "[$(date '+%H:%M:%S')] Package manager active: $proc" | tee -a "$LOG_FILE"
                fi
                break
            fi
        done

        # If package manager was running, check for changes after it finishes
        if [[ "$PKG_RUNNING" == "true" ]]; then
            # Wait for all package managers to finish
            while pgrep -f "${PROCESS_NAMES// /|}" >/dev/null 2>&1; do
                sleep 1
            done

            # Small delay to ensure package database is updated
            sleep 2

            # Check for new packages
            echo "[$(date '+%H:%M:%S')] Checking for newly installed packages..." | tee -a "$LOG_FILE"
            get_package_list "$pm" >"$MONITOR_FILE.current"

            if [[ -f "$MONITOR_FILE.previous" ]]; then
                NEW_PACKAGES=$(comm -13 "$MONITOR_FILE.previous" "$MONITOR_FILE.current")
                if [[ -n "$NEW_PACKAGES" ]]; then
                    echo -e "${GREEN}[$(date '+%H:%M:%S')] New packages detected:${NC}" | tee -a "$LOG_FILE"
                    echo "$NEW_PACKAGES" | while IFS= read -r pkg; do
                        echo "  + $pkg" | tee -a "$LOG_FILE"
                        echo "$pkg" >>"$INSTALLED_PACKAGES"
                    done
                    echo "" | tee -a "$LOG_FILE"
                fi
            fi

            # Update previous state
            cp "$MONITOR_FILE.current" "$MONITOR_FILE.previous"
        fi

        sleep 2
    done
}

# Function to cleanup on exit
cleanup() {
    echo -e "\n${YELLOW}Stopping package monitor...${NC}" | tee -a "$LOG_FILE"

    if [[ -f "$LOCK_FILE" ]]; then
        rm -f "$LOCK_FILE"
    fi

    # Kill background monitoring process if it exists
    if [[ -n "$MONITOR_PID" ]]; then
        kill "$MONITOR_PID" 2>/dev/null
    fi

    echo -e "${BLUE}Analyzing final package state...${NC}" | tee -a "$LOG_FILE"

    if [[ -f "$INSTALLED_PACKAGES" ]]; then
        PACKAGE_MANAGER=$(detect_package_manager)
        NEW_PACKAGES=$(sort "$INSTALLED_PACKAGES" | uniq)

        if [[ -n "$NEW_PACKAGES" ]]; then
            echo -e "\n${GREEN}=== SESSION SUMMARY ===${NC}"
            echo -e "${GREEN}Total packages installed during monitoring: $(echo "$NEW_PACKAGES" | wc -l)${NC}"
            echo ""
            echo -e "${GREEN}=== NEWLY INSTALLED PACKAGES ===${NC}"
            echo "$NEW_PACKAGES" | nl -w2 -s'. '

            echo -e "\n${YELLOW}=== UNINSTALL COMMANDS ===${NC}"
            UNINSTALL_CMD=$(get_uninstall_command "$PACKAGE_MANAGER")

            # Generate uninstall script
            UNINSTALL_SCRIPT="/tmp/uninstall_packages_$$.sh"
            echo "#!/bin/bash" >"$UNINSTALL_SCRIPT"
            echo "# Auto-generated uninstall script for monitored packages" >>"$UNINSTALL_SCRIPT"
            echo "# Generated on: $(date)" >>"$UNINSTALL_SCRIPT"
            echo "# Monitoring session PID: $$" >>"$UNINSTALL_SCRIPT"
            echo "" >>"$UNINSTALL_SCRIPT"

            echo "echo \"Uninstalling packages from monitoring session...\"" >>"$UNINSTALL_SCRIPT"
            echo "" >>"$UNINSTALL_SCRIPT"

            echo "# Individual uninstall commands:" >>"$UNINSTALL_SCRIPT"
            while IFS= read -r pkg; do
                echo "echo -e \"\\033[1;33mUninstalling: $pkg\\033[0m\"" >>"$UNINSTALL_SCRIPT"
                echo "$UNINSTALL_CMD \"$pkg\"" >>"$UNINSTALL_SCRIPT"
                echo "echo" >>"$UNINSTALL_SCRIPT"
            done <<<"$NEW_PACKAGES"

            echo "" >>"$UNINSTALL_SCRIPT"
            echo "# Bulk uninstall command (uncomment to use instead):" >>"$UNINSTALL_SCRIPT"
            PACKAGES_ONELINE=$(echo "$NEW_PACKAGES" | tr '\n' ' ' | sed 's/[[:space:]]*$//')
            echo "# $UNINSTALL_CMD $PACKAGES_ONELINE" >>"$UNINSTALL_SCRIPT"

            chmod +x "$UNINSTALL_SCRIPT"

            echo -e "${GREEN}Individual uninstall commands:${NC}"
            while IFS= read -r pkg; do
                echo "  $UNINSTALL_CMD $pkg"
            done <<<"$NEW_PACKAGES"

            echo -e "\n${GREEN}Bulk uninstall command:${NC}"
            echo "  $UNINSTALL_CMD $PACKAGES_ONELINE"

            echo -e "\n${BLUE}Files created:${NC}"
            echo -e "${BLUE}  Uninstall script: $UNINSTALL_SCRIPT${NC}"
            echo -e "${BLUE}  Package list: $INSTALLED_PACKAGES${NC}"
            echo -e "${BLUE}  Monitor log: $LOG_FILE${NC}"

        else
            echo -e "\n${GREEN}No new packages were installed during monitoring.${NC}"
        fi
    else
        echo -e "\n${GREEN}No new packages were installed during monitoring.${NC}"
    fi

    # Cleanup temp files (keep log and uninstall script)
    rm -f "$MONITOR_FILE"*

    echo -e "${GREEN}Monitor stopped. Check the files above for details.${NC}"
    exit 0
}

# Function to show help
show_help() {
    echo "Real-time Package Installation Monitor"
    echo ""
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "OPTIONS:"
    echo "  -h, --help     Show this help message"
    echo "  -v, --verbose  Enable verbose output"
    echo "  -d, --daemon   Run in daemon mode (background)"
    echo "  -q, --quiet    Quiet mode (minimal output)"
    echo ""
    echo "This script monitors package manager processes in real-time and tracks"
    echo "newly installed packages as they are installed. When stopped (Ctrl+C),"
    echo "it will display all packages installed during the session."
    echo ""
    echo "Supported package managers: apt, dnf, yum, pacman, zypper"
    echo ""
    echo "The script detects when package managers are running and checks for"
    echo "newly installed packages after each installation completes."
}

# Parse command line arguments
VERBOSE=false
DAEMON=false
QUIET=false

while [[ $# -gt 0 ]]; do
    case $1 in
    -h | --help)
        show_help
        exit 0
        ;;
    -v | --verbose)
        VERBOSE=true
        shift
        ;;
    -d | --daemon)
        DAEMON=true
        shift
        ;;
    -q | --quiet)
        QUIET=true
        shift
        ;;
    *)
        echo "Unknown option: $1"
        echo "Use -h or --help for usage information."
        exit 1
        ;;
    esac
done

# Check if already running
if [[ -f "$LOCK_FILE" ]]; then
    echo -e "${RED}Package monitor is already running (PID: $(cat "$LOCK_FILE")).${NC}"
    echo "Use 'kill $(cat "$LOCK_FILE")' to stop it, or remove $LOCK_FILE if stale."
    exit 1
fi

# Create lock file
echo $$ >"$LOCK_FILE"

# Set up signal handlers
trap cleanup INT TERM EXIT

# Detect package manager
PACKAGE_MANAGER=$(detect_package_manager)
if [[ "$PACKAGE_MANAGER" == "unknown" ]]; then
    echo -e "${RED}Error: No supported package manager found.${NC}"
    echo "Supported: apt, dnf, yum, pacman, zypper"
    exit 1
fi

# Initialize log file
echo "Package Monitor started at $(date)" >"$LOG_FILE"
echo "PID: $$" >>"$LOG_FILE"
echo "Package Manager: $PACKAGE_MANAGER" >>"$LOG_FILE"
echo "----------------------------------------" >>"$LOG_FILE"

if [[ "$QUIET" != "true" ]]; then
    echo -e "${GREEN}=== Real-time Package Installation Monitor Started ===${NC}"
    echo -e "${BLUE}Package Manager: $PACKAGE_MANAGER${NC}"
    echo -e "${BLUE}PID: $$${NC}"
    echo -e "${BLUE}Log file: $LOG_FILE${NC}"

    if [[ "$DAEMON" == "true" ]]; then
        echo -e "${YELLOW}Running in daemon mode...${NC}"
        echo -e "${YELLOW}Use 'kill $$' or 'kill \$(cat $LOCK_FILE)' to stop monitoring.${NC}"
    else
        echo -e "${YELLOW}Press Ctrl+C to stop monitoring and see results.${NC}"
    fi

    echo -e "${GREEN}Monitoring package manager activity...${NC}"
    echo -e "${BLUE}Install packages now - they will be detected automatically!${NC}"
fi

# Initialize package tracking
touch "$INSTALLED_PACKAGES"
get_package_list "$PACKAGE_MANAGER" >"$MONITOR_FILE.previous"

if [[ "$VERBOSE" == "true" ]]; then
    INITIAL_COUNT=$(wc -l <"$MONITOR_FILE.previous")
    echo -e "${BLUE}Initial package count: $INITIAL_COUNT${NC}" | tee -a "$LOG_FILE"
fi

# Start monitoring in background
if [[ "$DAEMON" == "true" ]]; then
    # Run monitoring in background and redirect output
    monitor_package_processes "$PACKAGE_MANAGER" "$VERBOSE" &
    MONITOR_PID=$!

    # Keep main process alive
    while true; do
        if ! kill -0 "$MONITOR_PID" 2>/dev/null; then
            break
        fi
        sleep 5
    done
else
    # Run monitoring in foreground
    monitor_package_processes "$PACKAGE_MANAGER" "$VERBOSE" &
    MONITOR_PID=$!

    # Wait for interruption
    while true; do
        sleep 1
    done
fi
